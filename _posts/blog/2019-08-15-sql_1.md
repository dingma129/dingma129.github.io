---
title: a faster replacement of pandas.DataFrame.to_sql
author: Ding Ma
layout: post
categories: [blog]
---

<span style="font-weight:bold;font-size:36px">0. Introduction</span>

When a `pandas.DataFrame` is really large, using its `.to_sql` method usually costs a lot of time. In this blog, I will introduce a much faster replacement using `io.StringIO`.

<span style="font-weight:bold;font-size:36px">1. Setup</span>
<span style="font-weight:bold;font-size:32px">1.1 DataFrame</span>
I will use the same pandas DataFrame as the one I used in the blog of [<span style="color:blue">Bokeh (part 2)</span>](https://dingma129.github.io/blog/2019/08/12/Bokeh_2.html). Its shape is `(10044,7)`, and it looks like the following
<center><img src="https://dingma129.github.io/assets/figures/blog/bokeh_2_data.png" width="600" ></center>
<span style="font-weight:bold;font-size:32px">1.2 SQL DataBase</span>
I will use a local PostgreSQL Database.
```python
from sqlalchemy import create_engine
# create a new engine
engine = create_engine('postgresql+psycopg2://postgres:{}@localhost/'.format(password))
# create a new database
with engine.connect() as conn:
    conn.execute("commit")
    conn.execute("CREATE DATABASE gapminder")
    conn.close()
# connect to gapminder database
engine = create_engine('postgresql+psycopg2://postgres:{}@localhost/gapminder'.format(password))
```

---
<span style="font-weight:bold;font-size:36px">2. Two Methods</span>
```python
# using pandas.DataFrame.to_sql
def to_sql_pd():
    df.to_sql('data', con=engine,if_exists='append')
    return None
from io import StringIO
# using io.StringIO
def to_sql_stringio():
    output = StringIO()
    df.to_csv(output,sep='\t',index=True,header=False)
    output.getvalue()
    output.seek(0)
    connection = engine.raw_connection()
    cursor = connection.cursor()
    cursor.copy_from(output,"data",null="")
    connection.commit()
    cursor.close()
    return None
```
---
<span style="font-weight:bold;font-size:36px">3. Comparison</span>
We run the program
```python
import timeit
n_times = 5
print("pandas:")
print("average timed used:\t{}s".format(timeit.timeit(lambda: to_sql_pd(), number=n_times)/n_times))
# make sure having correct number of rows
assert(engine.execute("select count(*) from data").fetchall()[0][0]==10044*5)
print("StringIO:")
print("average timed used:\t{}s".format(timeit.timeit(lambda: to_sql_stringio(), number=n_times)/n_times))
# make sure having correct number of rows
assert(engine.execute("select count(*) from data").fetchall()[0][0]==10044*5)
```
<center><img src="https://dingma129.github.io/assets/figures/blog/sql_compare.png" width="400" ></center>
We can see that this new method is much faster than `pandas.DataFrame.to_sql`.









```python
import plotly.express as px
fig1 = px.scatter(df, x="Fertility Rate", y="Life Expectancy", size="Population", color="Region",animation_frame="Year", animation_group="Country Name",range_x=(0,10),range_y=(18,90),width=1000,height=650,hover_name="Country Name", size_max=60,opacity=0.5)
fig1.show()
```
<center><embed src="https://dingma129.github.io/assets/active_image/plotly/plotly_gapminder.html" width="1150" height="700"></center>
---
<span style="font-weight:bold;font-size:36px">3. Compare with Bokeh</span>
* `plotly.express` is simple to use for easy purposes, but it does not provide a lot of functionalities. You still need to use `plotly` in order to achieve complicated function.
* `Bokeh` can achieve interactions using JavaScript Callbacks, but the codes are usually much longer.
* The size of the html generated by `plotly.express` (4.11MB) is much larger the one created by `Bokeh` (1.24MB).